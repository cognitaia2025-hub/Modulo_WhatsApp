"""
Nodo Recepcionista Optimizado con Slot Filling

Implementa las mejoras sugeridas:
- Slot filling en lugar de opciones r√≠gidas A/B/C
- Verificaci√≥n de datos faltantes (fecha/hora preferida)
- B√∫squeda din√°mica de slots disponibles
- Flujo m√°s natural y conversacional
"""

import logging
from typing import Dict, Any, List, Optional
from datetime import datetime, date, timedelta
from langchain_core.messages import AIMessage

from src.state.agent_state import WhatsAppAgentState
from src.utils.logging_config import setup_colored_logging
from src.utils.nlp_extractors import extraer_nombre_con_llm, extraer_seleccion
from src.medical.crud import get_paciente_by_phone, registrar_paciente_externo, get_doctor_by_id
from src.medical.slots import generar_slots_con_turnos

logger = setup_colored_logging()

# Configuraci√≥n de slot filling
DIAS_SEMANA = ['lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes', 's√°bado', 'domingo']
MESES = [
    'enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
    'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'
]

def recepcionista_optimizado_node(state: WhatsAppAgentState) -> Dict[str, Any]:
    \"\"\"\n    Nodo de recepcionista optimizado con slot filling.\n    \n    En lugar de mostrar opciones r√≠gidas A/B/C, este nodo:\n    1. Verifica qu√© datos faltan (fecha_deseada, hora_deseada)\n    2. Los pide de forma natural\n    3. Una vez obtenidos, busca slots disponibles\n    4. Presenta confirmaci√≥n natural en lugar de men√∫\n    \n    Args:\n        state: Estado del agente WhatsApp\n        \n    Returns:\n        Estado actualizado con flujo de slot filling\n    \"\"\"\n    logger.info(\"üè• === NODO RECEPCIONISTA OPTIMIZADO (SLOT FILLING) ===\")\n    \n    # Obtener datos del estado\n    estado_conv = state.get('estado_conversacion', 'inicial')\n    messages = state.get('messages', [])\n    paciente_phone = state.get('user_id', '')\n    fecha_deseada = state.get('fecha_deseada')\n    hora_deseada = state.get('hora_deseada')\n    intencion_confirmada = state.get('intencion_confirmada', False)\n    \n    if not messages:\n        logger.error(\"‚ùå No hay mensajes en el estado\")\n        return {**state, 'respuesta_recepcionista': \"Error: No hay mensajes\"}\n    \n    ultimo_mensaje = messages[-1]\n    mensaje_contenido = getattr(ultimo_mensaje, 'content', '')\n    \n    logger.info(f\"üì± Paciente: {paciente_phone}\")\n    logger.info(f\"üîÑ Estado: {estado_conv}\")\n    logger.info(f\"üìÖ Fecha deseada: {fecha_deseada}\")\n    logger.info(f\"‚è∞ Hora deseada: {hora_deseada}\")\n    logger.info(f\"üí¨ Mensaje: {mensaje_contenido[:50]}...\")\n    \n    try:\n        if estado_conv == 'inicial':\n            respuesta, nuevo_estado, slots, updates = _manejar_inicial_slot_filling(\n                paciente_phone, mensaje_contenido, fecha_deseada, hora_deseada\n            )\n            \n        elif estado_conv == 'solicitando_nombre':\n            respuesta, nuevo_estado, slots, updates = _manejar_solicitar_nombre_optimizado(\n                paciente_phone, mensaje_contenido\n            )\n            \n        elif estado_conv == 'recolectando_slots':\n            respuesta, nuevo_estado, slots, updates = _manejar_recoleccion_slots(\n                paciente_phone, mensaje_contenido, fecha_deseada, hora_deseada\n            )\n            \n        elif estado_conv == 'confirmando_cita':\n            respuesta, nuevo_estado, slots, updates = _manejar_confirmacion_final(\n                paciente_phone, mensaje_contenido, state.get('slots_disponibles', [])\n            )\n            \n        else:\n            # Estado desconocido, reiniciar\n            respuesta = \"Lo siento, algo sali√≥ mal. ¬øPodr√≠as decirme nuevamente qu√© necesitas?\"\n            nuevo_estado = 'inicial'\n            slots = []\n            updates = {'fecha_deseada': None, 'hora_deseada': None, 'intencion_confirmada': False}\n    \n    except Exception as e:\n        logger.error(f\"‚ùå Error en recepcionista optimizado: {e}\")\n        respuesta = \"Lo siento, ha ocurrido un error. ¬øPodr√≠as intentar de nuevo?\"\n        nuevo_estado = 'inicial'\n        slots = []\n        updates = {}\n    \n    # Crear mensaje AI\n    ai_message = AIMessage(content=respuesta)\n\n    # Actualizar estado\n    estado_actualizado = {\n        **state,\n        **updates,\n        'messages': [ai_message],\n        'respuesta_recepcionista': respuesta,\n        'estado_conversacion': nuevo_estado,\n        'slots_disponibles': slots,\n        'timestamp': datetime.now().isoformat()\n    }\n\n    logger.info(f\"‚úÖ Respuesta generada ({len(respuesta)} chars)\")\n    logger.info(f\"üîÑ Nuevo estado: {nuevo_estado}\")\n\n    return estado_actualizado\n\n\ndef _manejar_inicial_slot_filling(\n    paciente_phone: str, \n    mensaje: str, \n    fecha_deseada: Optional[str], \n    hora_deseada: Optional[str]\n) -> tuple[str, str, List[Dict], Dict[str, Any]]:\n    \"\"\"\n    Maneja el estado inicial con slot filling.\n    \n    Returns:\n        (respuesta, nuevo_estado, slots_disponibles, updates)\n    \"\"\"\n    logger.info(\"üü¢ Manejando inicial con slot filling\")\n    \n    # 1. Verificar si paciente existe\n    paciente = get_paciente_by_phone(paciente_phone)\n    \n    if not paciente:\n        logger.info(\"üÜï Paciente nuevo - solicitando nombre\")\n        respuesta = \"\"\"Hola!\n\nVeo que es tu primera vez. Para agendarte una cita, necesito tu nombre completo.\n\n¬øC√≥mo te llamas?\"\"\"\n        return respuesta, 'solicitando_nombre', [], {}\n    \n    nombre_paciente = paciente.get('nombre_completo', 'paciente').replace(' (Test)', '')\n    logger.info(f\"‚úÖ Paciente existente: {nombre_paciente}\")\n    \n    # 2. Extraer informaci√≥n de slot del mensaje actual\n    fecha_extraida = _extraer_fecha_del_mensaje(mensaje)\n    hora_extraida = _extraer_hora_del_mensaje(mensaje)\n    \n    # Actualizar slots con nueva informaci√≥n\n    if fecha_extraida:\n        fecha_deseada = fecha_extraida\n    if hora_extraida:\n        hora_deseada = hora_extraida\n    \n    # 3. Verificar qu√© informaci√≥n nos falta\n    if not fecha_deseada:\n        respuesta = f\"\"\"Hola {nombre_paciente}!\n\n¬øPara qu√© d√≠a te gustar√≠a la cita?\n\nPuedes decirme algo como:\n‚Ä¢ \"Para ma√±ana\"\n‚Ä¢ \"El viernes\"\n‚Ä¢ \"Para el 15 de febrero\"\"\"\n        \n        updates = {'fecha_deseada': fecha_deseada, 'hora_deseada': hora_deseada}\n        return respuesta, 'recolectando_slots', [], updates\n    \n    elif not hora_deseada:\n        respuesta = f\"\"\"Perfecto {nombre_paciente}, para {fecha_deseada}.\n\n¬øA qu√© hora prefieres?\n\nPuedes decirme:\n‚Ä¢ \"En la ma√±ana\"\n‚Ä¢ \"Por la tarde\" \n‚Ä¢ \"A las 10am\"\n‚Ä¢ \"Despu√©s de las 3pm\"\"\"\n        \n        updates = {'fecha_deseada': fecha_deseada, 'hora_deseada': hora_deseada}\n        return respuesta, 'recolectando_slots', [], updates\n    \n    else:\n        # Tenemos ambos datos, buscar slots y confirmar\n        slots = _buscar_slots_por_preferencias(fecha_deseada, hora_deseada)\n        \n        if not slots:\n            respuesta = f\"\"\"Lo siento {nombre_paciente}.\n\nNo tenemos disponibilidad para {fecha_deseada} {hora_deseada}.\n\n¬øTe funcionar√≠a otro d√≠a u horario?\"\"\"\n            \n            updates = {'fecha_deseada': None, 'hora_deseada': None}\n            return respuesta, 'recolectando_slots', [], updates\n        \n        # Presentar confirmaci√≥n natural (no men√∫ A/B/C)\n        mejor_slot = slots[0]  # Tomar el mejor match\n        respuesta = f\"\"\"Perfecto {nombre_paciente}!\n\nEncontr√© disponibilidad para:\nüìÖ {_formatear_slot_natural(mejor_slot)}\n\n¬øTe confirmo esta cita?\"\"\"\n        \n        updates = {\n            'fecha_deseada': fecha_deseada, \n            'hora_deseada': hora_deseada,\n            'intencion_confirmada': False\n        }\n        return respuesta, 'confirmando_cita', [mejor_slot], updates\n\n\ndef _manejar_recoleccion_slots(\n    paciente_phone: str,\n    mensaje: str, \n    fecha_deseada: Optional[str], \n    hora_deseada: Optional[str]\n) -> tuple[str, str, List[Dict], Dict[str, Any]]:\n    \"\"\"\n    Maneja la recolecci√≥n de informaci√≥n de slot faltante.\n    \"\"\"\n    logger.info(\"üìù Recolectando informaci√≥n de slot\")\n    \n    # Extraer nueva informaci√≥n del mensaje\n    fecha_extraida = _extraer_fecha_del_mensaje(mensaje)\n    hora_extraida = _extraer_hora_del_mensaje(mensaje)\n    \n    # Actualizar con nueva informaci√≥n\n    if fecha_extraida:\n        fecha_deseada = fecha_extraida\n    if hora_extraida:\n        hora_deseada = hora_extraida\n    \n    paciente = get_paciente_by_phone(paciente_phone)\n    nombre_paciente = paciente.get('nombre_completo', 'paciente').replace(' (Test)', '')\n    \n    # Verificar qu√© sigue faltando\n    if not fecha_deseada:\n        respuesta = \"\"\"¬øPara qu√© d√≠a te gustar√≠a la cita?\n\nPuedes decirme:\n‚Ä¢ \"Para ma√±ana\"\n‚Ä¢ \"El viernes\" \n‚Ä¢ \"Para el 25\"\"\"\n        \n        updates = {'fecha_deseada': fecha_deseada, 'hora_deseada': hora_deseada}\n        return respuesta, 'recolectando_slots', [], updates\n    \n    elif not hora_deseada:\n        respuesta = f\"\"\"Perfecto, para {fecha_deseada}.\n\n¬øA qu√© hora prefieres?\n\n‚Ä¢ \"En la ma√±ana\"\n‚Ä¢ \"Por la tarde\"\n‚Ä¢ \"A las 9am\"\n‚Ä¢ \"Despu√©s del mediod√≠a\"\"\"\n        \n        updates = {'fecha_deseada': fecha_deseada, 'hora_deseada': hora_deseada}\n        return respuesta, 'recolectando_slots', [], updates\n    \n    else:\n        # Ya tenemos todo, buscar y confirmar\n        slots = _buscar_slots_por_preferencias(fecha_deseada, hora_deseada)\n        \n        if not slots:\n            respuesta = f\"\"\"Lo siento {nombre_paciente}.\n\nNo hay disponibilidad para {fecha_deseada} {hora_deseada}.\n\n¬øPodr√≠as intentar con otro d√≠a u horario?\"\"\"\n            \n            updates = {'fecha_deseada': None, 'hora_deseada': None}\n            return respuesta, 'recolectando_slots', [], updates\n        \n        mejor_slot = slots[0]\n        respuesta = f\"\"\"Excelente {nombre_paciente}!\n\nTengo disponibilidad para:\nüìÖ {_formatear_slot_natural(mejor_slot)}\n\n¬øConfirmo esta cita?\"\"\"\n        \n        updates = {\n            'fecha_deseada': fecha_deseada,\n            'hora_deseada': hora_deseada,\n            'intencion_confirmada': False\n        }\n        return respuesta, 'confirmando_cita', [mejor_slot], updates\n\n\ndef _manejar_confirmacion_final(\n    paciente_phone: str,\n    mensaje: str,\n    slots_disponibles: List[Dict]\n) -> tuple[str, str, List[Dict], Dict[str, Any]]:\n    \"\"\"\n    Maneja la confirmaci√≥n final de la cita.\n    \"\"\"\n    logger.info(\"‚úÖ Manejando confirmaci√≥n final\")\n    \n    mensaje_lower = mensaje.lower().strip()\n    es_confirmacion = any(palabra in mensaje_lower for palabra in [\n        's√≠', 'si', 'confirmo', 'perfecto', 'ok', 'est√° bien', 'dale', 'confirma'\n    ])\n    es_negacion = any(palabra in mensaje_lower for palabra in [\n        'no', 'cancel', 'cambiar', 'otro', 'diferente'\n    ])\n    \n    if es_negacion:\n        respuesta = \"\"\"No hay problema.\n\n¬øPrefieres otro d√≠a u horario?\n\nDime cu√°ndo te funcionar√≠a mejor.\"\"\"\n        \n        updates = {\n            'fecha_deseada': None,\n            'hora_deseada': None,\n            'intencion_confirmada': False\n        }\n        return respuesta, 'recolectando_slots', [], updates\n    \n    elif es_confirmacion and slots_disponibles:\n        # Agendar la cita\n        slot_elegido = slots_disponibles[0]\n        try:\n            paciente = get_paciente_by_phone(paciente_phone)\n            doctor = get_doctor_by_id(slot_elegido['doctor_asignado_id'])\n            \n            # Agendar usando funci√≥n CRUD simplificada\n            from src.medical.crud import agendar_cita_simple\n            from datetime import datetime as dt\n            \n            fecha_inicio_str = f\"{slot_elegido['fecha']} {slot_elegido['hora_inicio']}\"\n            fecha_fin_str = f\"{slot_elegido['fecha']} {slot_elegido['hora_fin']}\"\n            fecha_inicio = dt.strptime(fecha_inicio_str, \"%Y-%m-%d %H:%M\")\n            fecha_fin = dt.strptime(fecha_fin_str, \"%Y-%m-%d %H:%M\")\n            \n            cita_id = agendar_cita_simple(\n                doctor_id=doctor['id'],\n                paciente_id=paciente['id'],\n                fecha_inicio=fecha_inicio,\n                fecha_fin=fecha_fin,\n                motivo=\"Cita agendada via WhatsApp\"\n            )\n            \n            if cita_id:\n                respuesta = f\"\"\"Perfecto! Tu cita ha sido agendada.\n\nDetalles:\nüìÖ {_formatear_detalle_slot(slot_elegido, doctor['nombre_completo'])}\n\nTe esperamos!\"\"\"\n                \n                updates = {'intencion_confirmada': True}\n                return respuesta, 'completado', slots_disponibles, updates\n            else:\n                respuesta = \"\"\"Lo siento, hubo un problema al agendar la cita.\n\n¬øPodr√≠as intentar de nuevo?\"\"\"\n                \n                return respuesta, 'inicial', [], {}\n                \n        except Exception as e:\n            logger.error(f\"‚ùå Error agendando cita: {e}\")\n            respuesta = \"\"\"Ha ocurrido un problema al agendar.\n\n¬øPodr√≠as contactarnos por tel√©fono?\"\"\"\n            \n            return respuesta, 'inicial', [], {}\n    \n    else:\n        # Respuesta ambigua, pedir confirmaci√≥n clara\n        respuesta = \"\"\"¬øConfirmas la cita?\n\nPuedes responder:\n‚Ä¢ \"S√≠, confirmo\"\n‚Ä¢ \"No, prefiero otro horario\"\"\"\n        \n        return respuesta, 'confirmando_cita', slots_disponibles, {}\n\n\ndef _manejar_solicitar_nombre_optimizado(\n    paciente_phone: str,\n    mensaje: str\n) -> tuple[str, str, List[Dict], Dict[str, Any]]:\n    \"\"\"\n    Maneja la solicitud de nombre optimizada.\n    \"\"\"\n    logger.info(\"üìù Solicitando nombre optimizado\")\n    \n    nombre = extraer_nombre_con_llm(mensaje)\n    \n    if not nombre or len(nombre.strip()) < 2:\n        respuesta = \"\"\"No pude entender tu nombre.\n\n¬øPodr√≠as dec√≠rmelo de nuevo?\n\nPor ejemplo: \"Soy Juan P√©rez\"\"\"\n        \n        return respuesta, 'solicitando_nombre', [], {}\n    \n    # Registrar paciente\n    try:\n        resultado = registrar_paciente_externo(paciente_phone, nombre)\n        logger.info(f\"‚úÖ Paciente registrado: {resultado}\")\n        \n        respuesta = f\"\"\"Gracias {nombre}!\n\nYa te registr√© en el sistema.\n\n¬øPara qu√© d√≠a te gustar√≠a la cita?\"\"\"\n        \n        return respuesta, 'recolectando_slots', [], {}\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Error registrando paciente: {e}\")\n        respuesta = \"\"\"Ha ocurrido un problema al registrarte.\n\n¬øPodr√≠as intentar m√°s tarde?\"\"\"\n        \n        return respuesta, 'inicial', [], {}\n\n\n# ==================== FUNCIONES AUXILIARES ====================\n\ndef _extraer_fecha_del_mensaje(mensaje: str) -> Optional[str]:\n    \"\"\"\n    Extrae informaci√≥n de fecha del mensaje usando patrones simples.\n    \n    TODO: Implementar con LLM para mayor precisi√≥n.\n    \"\"\"\n    mensaje_lower = mensaje.lower()\n    \n    # Patrones b√°sicos\n    if 'ma√±ana' in mensaje_lower:\n        fecha = (datetime.now() + timedelta(days=1)).strftime('%Y-%m-%d')\n        return f\"ma√±ana ({fecha})\"\n    \n    elif 'pasado ma√±ana' in mensaje_lower:\n        fecha = (datetime.now() + timedelta(days=2)).strftime('%Y-%m-%d')\n        return f\"pasado ma√±ana ({fecha})\"\n    \n    # D√≠as de la semana\n    for i, dia in enumerate(DIAS_SEMANA):\n        if dia in mensaje_lower:\n            # Calcular pr√≥ximo d√≠a de la semana\n            hoy = datetime.now().weekday()\n            dias_hasta = (i - hoy) % 7\n            if dias_hasta == 0:\n                dias_hasta = 7  # Siguiente semana\n            fecha = (datetime.now() + timedelta(days=dias_hasta)).strftime('%Y-%m-%d')\n            return f\"{dia} ({fecha})\"\n    \n    return None\n\n\ndef _extraer_hora_del_mensaje(mensaje: str) -> Optional[str]:\n    \"\"\"\n    Extrae informaci√≥n de hora del mensaje.\n    \"\"\"\n    mensaje_lower = mensaje.lower()\n    \n    # Patrones de hora\n    if any(palabra in mensaje_lower for palabra in ['ma√±ana', 'temprano', '8', '9', '10']):\n        return \"en la ma√±ana\"\n    elif any(palabra in mensaje_lower for palabra in ['tarde', 'despu√©s', '2', '3', '4', '5']):\n        return \"por la tarde\"\n    elif any(palabra in mensaje_lower for palabra in ['noche', 'nocturno', '6', '7', '8pm']):\n        return \"en la noche\"\n    \n    # Horas espec√≠ficas (b√°sico)\n    import re\n    patron_hora = re.search(r'(\\d{1,2})(?::\\d{2})?\\s*(?:am|pm|hrs?)?', mensaje_lower)\n    if patron_hora:\n        return f\"a las {patron_hora.group(0)}\"\n    \n    return None\n\n\ndef _buscar_slots_por_preferencias(fecha_deseada: str, hora_deseada: str) -> List[Dict]:\n    \"\"\"\n    Busca slots disponibles seg√∫n las preferencias del usuario.\n    \n    TODO: Implementar algoritmo inteligente de matching.\n    Por ahora usa la funci√≥n existente como fallback.\n    \"\"\"\n    logger.info(f\"üîç Buscando slots para: {fecha_deseada} {hora_deseada}\")\n    \n    # Por ahora, usar generador existente y filtrar\n    slots = generar_slots_con_turnos(dias_adelante=14)\n    \n    if not slots:\n        return []\n    \n    # Filtrado b√°sico por hora preferida\n    slots_filtrados = []\n    for slot in slots:\n        hora_slot = slot.get('hora_inicio', '')\n        \n        if 'ma√±ana' in hora_deseada.lower() and hora_slot < '12:00':\n            slots_filtrados.append(slot)\n        elif 'tarde' in hora_deseada.lower() and '12:00' <= hora_slot < '18:00':\n            slots_filtrados.append(slot)\n        elif 'noche' in hora_deseada.lower() and hora_slot >= '18:00':\n            slots_filtrados.append(slot)\n        else:\n            # Si no hay filtro espec√≠fico, incluir todos\n            slots_filtrados.append(slot)\n    \n    # Retornar m√°ximo 3 mejores opciones\n    return slots_filtrados[:3] if slots_filtrados else slots[:3]\n\n\ndef _formatear_slot_natural(slot: Dict) -> str:\n    \"\"\"\n    Formatea un slot de manera natural (no como opci√≥n A/B/C).\n    \"\"\"\n    fecha_obj = date.fromisoformat(slot['fecha'])\n    dia_nombre = DIAS_SEMANA[fecha_obj.weekday()]\n    dia_numero = fecha_obj.day\n    mes_nombre = MESES[fecha_obj.month - 1]\n    \n    hora_inicio = slot['hora_inicio'][:5]\n    hora_fin = slot['hora_fin'][:5]\n    \n    return f\"{dia_nombre.title()} {dia_numero} de {mes_nombre}, {hora_inicio} - {hora_fin}\"\n\n\ndef _formatear_detalle_slot(slot: Dict, doctor_nombre: str) -> str:\n    \"\"\"\n    Formatea el detalle completo del slot para confirmaci√≥n final.\n    \"\"\"\n    fecha_obj = date.fromisoformat(slot['fecha'])\n    dia_nombre = DIAS_SEMANA[fecha_obj.weekday()]\n    dia_numero = fecha_obj.day\n    mes_nombre = MESES[fecha_obj.month - 1]\n    \n    hora_inicio = slot['hora_inicio'][:5]\n    hora_fin = slot['hora_fin'][:5]\n    \n    return f\"\"\"üìÖ Fecha: {dia_nombre.title()} {dia_numero} de {mes_nombre}\nüïê Hora: {hora_inicio} a {hora_fin}\nüë®‚Äç‚öïÔ∏è Doctor: {doctor_nombre}\"\"\"\n\n\n# Wrapper para compatibilidad\ndef nodo_recepcionista_optimizado_wrapper(state: WhatsAppAgentState) -> Dict[str, Any]:\n    \"\"\"\n    Wrapper que mantiene la firma esperada por el grafo.\n    \"\"\"\n    try:\n        return recepcionista_optimizado_node(state)\n    except Exception as e:\n        logger.error(f\"‚ùå Error en recepcionista optimizado: {e}\")\n        return {\n            **state,\n            'respuesta_recepcionista': \"Error en el sistema de citas. Int√©ntalo m√°s tarde.\",\n            'estado_conversacion': 'inicial'\n        }